{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Spring Boot Operator","text":"<p>The Spring Boot Operator allows your application developers to focus on what's important for deploying spring boot (web) applications to Kubernetes. </p> <p>By creating a simple API, the spring boot operator cuts all the unnecessary boilerplate down to a single simple solution. Incoorporating best practices when it comes to security out the box.</p>"},{"location":"#why-use-this-operator","title":"Why use this operator?","text":"<p>If you want to deploy a spring boot application, you have to first build a complex deployment spec, expose it with a service, create a configmap for the spring boot configuration and that's before they've worried about scaling or security best practice. The spring boot operator simplifies this process - simplifying the process of deploying spring boot applications down to a single, simple yaml document.</p>"},{"location":"#how-does-it-work","title":"How does it work?","text":"<p>The operator works by provisioning the resources you need to run a spring boot application with none of the extra fluff.</p> <pre><code>flowchart TD\n    app[\"SpringBootApplication\"]\n    cm[\"ConfigMap for application.yaml\"]\n    dep[\"Deployment\"]\n    svc[\"Service\"]\n    hpa[\"HorizontalPodAutoscaler\"]\n\n    app -- generates --&gt; hpa\n    app -- generates --&gt; dep\n    app -- generates --&gt; svc\n    app -- generates --&gt; cm\n\n    cm -- mounted to --&gt; dep\n    svc -- exposes --&gt; dep\n    hpa -- scales --&gt; dep</code></pre>"},{"location":"#samples","title":"Samples","text":"<p>To view some example CRDs, have a look here.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#spring-boot-configuration","title":"Spring Boot Configuration","text":"<p>Spring boot apps may be configured with an <code>application.yaml</code> file. Since yaml works quite nicely with Kubernetes objects, we support that over the properties style.</p> <p>You can add configuration to your spring boot application easily using the <code>config</code> field like in this example.</p> <p>Default configurations</p> <p>The port and context-path are defaulted in the generated application.yaml based on the <code>spec.port</code> and <code>spec.contextPath</code> properties. This is done to ensure that configuration, service settings and healthchecks can be correctly set.</p>"},{"location":"features/#health-checks","title":"Health checks","text":"<p>To stop traffic heading to your spring application before it's ready, we use health checks designed around Spring actuator. If you haven't added spring actuator as a dependency, add this to your pom.xml file:</p> pom.xml<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"features/#autoscaling","title":"Autoscaling","text":"<p>Your application will be equipped with a horizontal pod autoscaler which will increase and decrease the number of replicas based on cpu load.</p> <p>By default, we determine the scaling behaviour from the <code>spec.type</code> field. This indicates to use which type of spring boot app you're deploying. This can be either:</p> Setting Framework Characteristics CPU Target Scale-Up Stabilization <code>web</code> Spring Web Slower startup, higher resource usage 70% 50% / 60s 30s <code>webflux</code> Spring WebFlux Moderate startup, more CPU efficient 75% 75% / 60s 20s <code>native</code> Spring Native (GraalVM) Rapid startup, highly burstable 65% 100% / 30s 10s <p>The default setting is <code>web</code>.</p> <p>However you can override these by using the following properties:</p> <pre><code>spec:\n  autoscaler:\n    minReplicas: 2 # Default value\n    maxReplicas: 10 # Default value\n    targetUtilization:\n      cpuPercent: 70 # We may add more types in future for IO bound apps\n    behavior:\n      scaleUp:\n        stabilizationWindowSeconds: 10\n        policies:\n          - type: Percent\n            value: 100\n            periodSeconds: 30\n      scaleDown:\n        stabilizationWindowSeconds: 180\n</code></pre> <p>If you want to learn more about the custom scaling behaviour, you can read more here.</p>"},{"location":"features/#resource-setting","title":"Resource setting","text":"<p>By default when you provsion a minimal spring boot application, it will be provisioned with the following resources:</p> <pre><code>resources:\n  requests:\n    cpu: 1\n    memory: 1Gi\n  limits:\n    memory: 1Gi\n</code></pre> <p>This is the default and follows the following best practices:</p> <ul> <li>Not setting CPU limits to prevent unnecessary throttling</li> <li>Setting Memory Limits to avoid OOMKilled events</li> </ul> <p>This works well with container aware versions of java (11+).</p> <p>You can alter this by either changing the <code>resourcePreset</code> or configuring the <code>resources</code> manually to specify specific values. The presets available are:</p> <ul> <li>small (1Gi memory and 1 vCPU)</li> <li>medium (2Gi memory and 2 vCPU)</li> <li>large (4Gi memory and 4vCPU)</li> </ul> <p>Setting both won't work</p> <p>You can't both have a preset and set the resources manually, you have to choose. If you set both, the controller will remove the preset and your custom values will be used.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>To get started with the Spring Boot Operator, you will need to install the Operator to your cluster. For production settings, we recommend using the Operator Lifecycle Manager to install the operator.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Your kubernetes cluster is at v1.30+</li> <li>Your application uses java 11+</li> <li>Your application uses spring boot 2+</li> </ul>"},{"location":"getting-started/#quickstart","title":"Quickstart","text":"<p>To install the latest version of the operator, ensure you have Cert Manager installed in your cluster. Then you can install using <code>kubectl</code>:</p> <pre><code>kubectl apply -f https://github.com/Dante-lor/spring-boot-operator/releases/download/v0.1.1/install.yaml\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<p>Assuming you meet the prerequisites and have installed the opartor, deploying a vanilla spring application is as simple as:</p> <pre><code>DOCKER_IMAGE=example:latest\n\nkubectl apply -f - &lt;&lt;EOF\napiVersion: spring.dante-lor.github.io/v1alpha1\nkind: SpringBootApplication\nmetadata:\n  name: my-app\nspec:\n  image: $DOCKER_IMAGE\nEOF\n</code></pre> <p>If you want to dive deeper into what features and configuration options are available, check out our Feature page.</p>"},{"location":"installation/olm/","title":"Installing the Spring Boot Operator via OLM","text":"<p>The Operator Lifecycle Manager (OLM) is the recommended way to install and manage the Spring Boot Operator in a cluster. OLM handles installation, upgrades, and dependency management automatically.</p>"},{"location":"installation/olm/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure the following are available in your environment:</p> <ul> <li>A running Kubernetes cluster (v1.30+)</li> <li><code>kubectl</code> configured to point to your cluster</li> <li>OLM installed in the cluster (see below if not already installed)</li> <li>Sufficient permissions to create cluster-scoped resources (ClusterRole, CatalogSource, etc.)</li> </ul>"},{"location":"installation/olm/#step-1-install-olm-if-not-already-present","title":"Step 1 \u2014 Install OLM (if not already present)","text":"<p>If your cluster does not have OLM installed, you can install it using the Operator SDK CLI:</p> <pre><code>operator-sdk olm install\n</code></pre> <p>To verify OLM is running:</p> <pre><code>kubectl get pods -n olm\n</code></pre> <p>All pods in the <code>olm</code> namespace should be in the <code>Running</code> state before proceeding.</p>"},{"location":"installation/olm/#step-2-add-the-catalog-source","title":"Step 2 \u2014 Add the Catalog Source","text":"<p>The catalog source tells OLM where to find the Spring Boot Operator bundle. Apply the following manifest to register it with your cluster:</p> <pre><code>apiVersion: operators.coreos.com/v1alpha1\nkind: CatalogSource\nmetadata:\n  name: spring-boot-operator-catalog\n  namespace: olm\nspec:\n  sourceType: grpc\n  image: ghcr.io/dante-lor/spring-boot-operator-catalog:latest\n  displayName: Spring Boot Operator\n  publisher: dante-lor\n  updateStrategy:\n    registryPoll:\n      interval: 10m\n</code></pre> <p>Apply it with:</p> <pre><code>kubectl apply -f catalogsource.yaml\n</code></pre> <p>Verify the catalog source is ready:</p> <pre><code>kubectl get catalogsource -n olm spring-boot-operator-catalog\n</code></pre> <p>The <code>STATUS</code> column should show <code>READY</code>.</p>"},{"location":"installation/olm/#step-3-create-a-namespace-and-operatorgroup","title":"Step 3 \u2014 Create a Namespace and OperatorGroup","text":"<p>OLM requires an <code>OperatorGroup</code> to define the install scope of the operator. The example below installs the operator into a dedicated namespace and configures it to watch all namespaces. Adjust <code>targetNamespaces</code> to restrict the watch scope if needed.</p> <pre><code>kubectl create namespace spring-boot-operator-system\n</code></pre> <pre><code>apiVersion: operators.coreos.com/v1\nkind: OperatorGroup\nmetadata:\n  name: spring-boot-operator-group\n  namespace: spring-boot-operator-system\nspec:\n  # Omitting targetNamespaces causes the operator to watch all namespaces.\n  # To restrict to specific namespaces, add them as a list:\n  # targetNamespaces:\n  #   - my-app-namespace\n</code></pre> <pre><code>kubectl apply -f operatorgroup.yaml\n</code></pre>"},{"location":"installation/olm/#step-4-create-a-subscription","title":"Step 4 \u2014 Create a Subscription","text":"<p>The <code>Subscription</code> resource instructs OLM to install the operator and keep it up to date:</p> <pre><code>apiVersion: operators.coreos.com/v1alpha1\nkind: Subscription\nmetadata:\n  name: spring-boot-operator\n  namespace: spring-boot-operator-system\nspec:\n  channel: alpha\n  name: spring-boot-operator\n  source: spring-boot-operator-catalog\n  sourceNamespace: olm\n  # Pin to a specific version by setting startingCSV, e.g.:\n  # startingCSV: spring-boot-operator.v0.1.1\n</code></pre> <pre><code>kubectl apply -f subscription.yaml\n</code></pre>"},{"location":"installation/olm/#step-5-verify-the-installation","title":"Step 5 \u2014 Verify the Installation","text":"<p>OLM will now install the operator. Track the progress by checking the <code>ClusterServiceVersion</code> (CSV):</p> <pre><code>kubectl get csv -n spring-boot-operator-system\n</code></pre> <p>Wait until the <code>PHASE</code> column shows <code>Succeeded</code>:</p> <pre><code>NAME                            DISPLAY                 VERSION   REPLACES   PHASE\nspring-boot-operator.v0.1.1    Spring Boot Operator    0.1.1                Succeeded\n</code></pre> <p>You can also verify the operator pod is running:</p> <pre><code>kubectl get pods -n spring-boot-operator-system\n</code></pre>"},{"location":"installation/olm/#upgrading","title":"Upgrading","text":"<p>When a new version of the catalog image is published, OLM will detect it automatically based on the <code>registryPoll</code> interval defined in the <code>CatalogSource</code> (default: 10 minutes). If you are subscribed to a channel, the upgrade will be applied automatically.</p> <p>To trigger an immediate check, you can delete and recreate the catalog source pod:</p> <pre><code>kubectl delete pod -n olm -l olm.catalogSource=spring-boot-operator-catalog\n</code></pre> <p>To pin to a specific version and manage upgrades manually, set <code>installPlanApproval: Manual</code> in your <code>Subscription</code>:</p> <pre><code>spec:\n  installPlanApproval: Manual\n</code></pre> <p>With manual approval, you must approve each <code>InstallPlan</code> as it is created:</p> <pre><code># List pending install plans\nkubectl get installplan -n spring-boot-operator-system\n\n# Approve a specific install plan\nkubectl patch installplan &lt;install-plan-name&gt; \\\n  -n spring-boot-operator-system \\\n  --type merge \\\n  --patch '{\"spec\":{\"approved\":true}}'\n</code></pre>"},{"location":"installation/olm/#uninstalling","title":"Uninstalling","text":"<p>To remove the operator and all associated resources:</p> <pre><code># Delete the subscription to stop future upgrades\nkubectl delete subscription spring-boot-operator -n spring-boot-operator-system\n\n# Delete the CSV to remove the operator itself\nkubectl delete csv spring-boot-operator.v0.1.1 -n spring-boot-operator-system\n\n# Remove the OperatorGroup and namespace\nkubectl delete operatorgroup spring-boot-operator-group -n spring-boot-operator-system\nkubectl delete namespace spring-boot-operator-system\n\n# Remove the catalog source\nkubectl delete catalogsource spring-boot-operator-catalog -n olm\n</code></pre> <p>Note: Deleting the operator does not automatically remove Custom Resource Definitions (CRDs) or any custom resources you have created. Remove these manually if they are no longer needed to avoid orphaned resources in your cluster.</p>"},{"location":"installation/olm/#troubleshooting","title":"Troubleshooting","text":"<p>CatalogSource not becoming READY Check the catalog pod logs in the <code>olm</code> namespace: <pre><code>kubectl get pods -n olm -l olm.catalogSource=spring-boot-operator-catalog\nkubectl logs -n olm &lt;catalog-pod-name&gt;\n</code></pre> Ensure the catalog image is publicly accessible from your cluster or that image pull secrets are configured.</p> <p>CSV stuck in <code>Installing</code> or <code>Failed</code> phase Inspect the CSV events and status: <pre><code>kubectl describe csv spring-boot-operator.v0.1.1 -n spring-boot-operator-system\n</code></pre></p> <p>No packages found in subscription Confirm the <code>source</code> and <code>sourceNamespace</code> in your <code>Subscription</code> match the <code>name</code> and <code>namespace</code> of your <code>CatalogSource</code> exactly.</p>"},{"location":"installation/olm/#additional-resources","title":"Additional Resources","text":"<ul> <li>OLM Documentation</li> <li>Operator SDK OLM Integration Guide</li> <li>Spring Boot Operator Releases</li> </ul>"}]}